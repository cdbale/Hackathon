---
title: "South Korea COVID-19 Patient Trajectory Analysis"
output: github_document
---

<br>

This project utilizes data on COVID-19 patients in South Korea. We thank those who have worked to provide the **DS4C: Data Science for COVID-19 in South Korea** [kaggle](https://www.kaggle.com/kimjihoo/coronavirusdataset) and [Github](https://github.com/ThisIsIsaac/Data-Science-for-COVID-19) pages.

The data we use comes from the previously mentioned [kaggle](https://www.kaggle.com/kimjihoo/coronavirusdataset) webpage. See data description [here.](https://www.kaggle.com/kimjihoo/ds4c-what-is-this-dataset-detailed-description)

***

## Overview

```{r setup, include = FALSE}
knitr::opts_chunk$set(fig.width = 10,
                      fig.height = 8)
```

First, install and load necessary packages. We use the `tidyverse` package for data manipulation and visualization, the `ggridges` package for plotting densities, and the `patchwork` package for displaying multiple plots together.
```{r message = FALSE, warning = FALSE}
#install.packages('tidyverse')
#install.packages('patchwork')
#install.packages('gridExtra')
library(tidyverse)
library(patchwork)
library(ggridges)
library(gridExtra)
```

<br>

## Analysis

The data file `korea_covid_clean.RData` was created using the `korea_data_cleaning.R` [script.](https://github.com/cdbale/Hackathon/blob/master/Code/korea_data_cleaning.R)

<br>
  
Load the cleaned patient information and routes data.
```{r}
load(file = "../Data/korea_data_clean.RData")
head(full)
```

<br>

Create data consisting of `patient_id` and location trajectories (`latitude`/`longitude`) only for individuals with at least 5 observed location points.
```{r}
trajectories <- full %>%
  select(patient_id, latitude, longitude) %>%
  drop_na() %>%
  group_by(patient_id) %>%
  filter(n() > 4)

head(trajectories)
```

<br>

We define a trajectory as unique if it differs by at least one location observation from all other observed trajectories. Since individuals have varying trajectory lengths, we take a random sample of points from each trajectory in order to be able to compare them. We will see later that the percentage of unique trajectories increases with the number of sampled points. We compare all tajectories samples and determine what percentage of them are unique.

<br> 

To perform this calculation, we define a function `trajectory_uniqueness` which takes as inputs the data consisting of three variables: an individual identifier and latitude and longitude measurements, and the number of times (`nits`) we want to sample `num_points` points from each trajectory and calculate the percentage of unique trajectories. (This function assumes that in the data passed to it, `patient_id` uniquely identifies individuals, and the only other columns are `latitude` and `longitude`).
```{r}
trajectory_uniqueness <- function(trajectory_data, num_points, nits = 1)
{
  split_trajectories <- trajectory_data %>% 
    group_by(patient_id) %>%
    group_split(keep = FALSE)
  
  ntrajectories <- length(split_trajectories)
    
  p_unique <- replicate(n = nits, length(unique(lapply(split_trajectories, 
                                                  function(x) sample_n(x, size = num_points))))/ntrajectories)
  
  return(100 * p_unique)
}
```

<br>

To illustrate the privacy risks that exist in this data, we will run the `split_trajectories` function 100 times for each sample size of one through five points. The percentages generated by this function are saved for later access.
```{r}
up_5d <- map_dfc(1:5, function(x) trajectory_uniqueness(trajectories, num_points = x, nits = 100))
save(up_5d, file = '../Data/pct_unique_5d.RData')
#load('pct_unique_5d.RData')
```

<br>

For the purposes of our analysis, we need to add meaningful column names, reshape the data for easy plotting, and add a variable, `specificity` which indicates how many decimal places we had in our `latitude` and `longitude` measurements. For these first results, `latitude` had five decimal places and `longitude` had four. So, we will label this `specificity` as 5.
```{r}
pvar_names <- c('one', 'two', 'three', 'four', 'five')

colnames(up_5d) <- pvar_names

up_5d <- up_5d %>%
  gather(key = 'num_points', value = 'percent_unique') %>%
  mutate(specificity = 5)
```

We can plot the distributions of unique percentages for each sample size with our original data (five decimal `latitude` and four decimal `longitude`.)
```{r message = FALSE}
ridge_plot <- function(percentage_data, specificity)
{
  p <- percentage_data %>%
  mutate(num_points = factor(num_points, levels = c('one', 'two', 'three', 'four', 'five'))) %>%
  ggplot(aes(x = percent_unique, y = factor(num_points))) +
  labs(x = 'Percent Unique',
       y = 'Number Sampled Points',
       title = paste('Percent Unique Trajectories by Sample Size for', specificity)) +
  geom_density_ridges(rel_min_height = 0.001) +
  scale_y_discrete(expand = c(0,0)) +
  scale_x_continuous(expand = c(0,0)) +
  xlim(min(percentage_data$percent_unique), 100) +
  coord_cartesian(clip = 'off') +
  theme_ridges()
  
  return(p)
}

ridge_plot(up_5d, '5 Decimal Lat/4 Decimal Long')
```

<br>

Now we examine the effects of rounding `latitude` and `longitude` on trajectory uniqueness. This is a relatively simple way to increase the privacy of individual location trajectories by reducing the specificity of the measured `latitude` and `longitude`. This comes at the cost of reducing the precision of individuals' locations thereby reducing the ability to track who a given individual comes in contact with. This tradeoff has important implications for both individual privacy and COVID-19 tracking applications.

<br>

In this data, `latitude` has five decimal places and `longitude` has four. We'll start by rounding `latitude` to four decimals. After rounding, we can re-measure the percentage of unique trajectories in the data. But to measure the tradeoff between the percentage of unique trajectories and the usefulness of the data, we need to quantify how far individuals' locations are shifted when we round `latitude` and `longitude` values.

<br>

This [Wikipedia page](https://en.wikipedia.org/wiki/Decimal_degrees) is a quick reference of the approximate distances represented by changes in `latitude` and `longitude`. Notice that a change in `latitude` of a certain amount, e.g. 0.01, is always equivalent to the same shift measured in kilometers, meters, or millimeters. However, the distance represented by a change in `longitude`, or a change in both `latitude` and `longitude` is not as easily calculated and varies depending on the distance North or South of the equator.

<br>

The [Haversine Formula](https://en.wikipedia.org/wiki/Haversine_formula) enables us to make fairly accurate calculations of the distance that someone traveled between two measured `latitude` and `longitude` points. In this case, we can measure how far an individuals' location observation is shifted by rounding. The function below, `hav_dist`, performs this calculation. Other sources used in this calculation can be found [here](http://www.movable-type.co.uk/scripts/latlong.html), [here](https://www.html5rocks.com/en/tutorials/geolocation/trip_meter/#toc-step6), and [here](https://stackoverflow.com/questions/639695/how-to-convert-latitude-or-longitude-to-meters).
```{r}
hav_dist <- function(lat1, long1, lat2, long2){
  r <- 6371.0088 # average radius of the earth in kilometers
  dlat <- (lat2 * pi/180) - (lat1 * pi/180)
  dlong <- (long2 * pi/180) - (long1 * pi/180)
  a <- sin(dlat/2)^2 + cos(lat1*pi/180) * cos(lat2*pi/180) * sin(dlong/2)^2
  d <- 2 * r * atan2(sqrt(a), sqrt(1 - a)) * 1000 # multiply by 1000 to convert to meters
  return(d)
}
```

<br>

Start by rounding latitude so that latitude and longitude are at the same specificity, four decimals, and remeasuring uniqueness.
```{r message = FALSE}
trajectories_4d <- trajectories %>%
  mutate(latitude2 = round(latitude, digits = 4),
         distances = hav_dist(latitude, longitude, latitude2, longitude))

up_4d <- map_dfc(1:5, function(x) trajectory_uniqueness(trajectories_4d[,c(1, 4, 5)], num_points = x, nits = 100))
save(up_4d, file = '../Data/pct_unique_4d.RData')
#load('pct_unique_4d.RData')

colnames(up_4d) <- pvar_names

up_4d <- up_4d %>%
  gather(key = 'num_points', value = 'percent_unique') %>%
  mutate(specificity = 4)
```

Define a function to quickly plot the distribution of distances shifted.
```{r message = FALSE}
dist_plot <- function(percentage_data, specificity) {
  p <- percentage_data %>%
    ggplot(aes(x = distances)) +
    geom_histogram() +
    labs(x = 'Distance Shifted in Meters',
         y = 'Count of Individuals',
         title = paste('Distances Shifted When Rounding to', specificity))
  
  return(p)
}
```

```{r message = FALSE}
ridge_plot(up_4d, 'Four Decimal Lat/Long') / dist_plot(trajectories_4d, 'Four Decimal Lat/Long')
```

Display quantiles of distances shifted when rounding to four decimal `latitude` and `longitude`.
```{r}
dist_quants <- function(percentage_data){
  qs <- percentage_data %>%
    ungroup() %>%
    summarize(Min = min(distances),
            `2.5%` = quantile(distances, probs = .025),
            `50%` = median(distances),
            `97.5%` = quantile(distances, probs = 0.975),
            Max = max(distances))
  return(qs)
}

(q4d <- dist_quants(trajectories_4d) %>% mutate(specificity = 4))
```

Now, we will round `latitude` and `longitude` simultaneously to three decimals.
```{r message = FALSE}
trajectories_3d <- trajectories %>%
  mutate(latitude2 = round(latitude, digits = 3),
         longitude2 = round(longitude, digits = 3),
         distances = hav_dist(latitude, longitude, latitude2, longitude2))

up_3d <- map_dfc(1:5, function(x) trajectory_uniqueness(trajectories_3d[,c(1, 4, 5)], num_points = x, nits = 100))
save(up_3d, file = '../Data/pct_unique_3d.RData')
#load('pct_unique_3d.RData')

colnames(up_3d) <- pvar_names

up_3d <- up_3d %>%
  gather(key = 'num_points', value = 'percent_unique') %>%
  mutate(specificity = 3)

ridge_plot(up_3d, 'Three Decimal Lat/Long') / dist_plot(trajectories_3d, 'Three Decimal Lat/Long')
```

```{r}
(q3d <- dist_quants(trajectories_3d) %>% mutate(specificity = 3))
```

Now, we will round `latitude` and `longitude` simultaneously to two decimals. Rounding from three decimals to two decimals results in a change of ___________ meters depending on distance from the equator.
```{r message = FALSE}
trajectories_2d <- trajectories %>%
  mutate(latitude2 = round(latitude, digits = 2),
         longitude2 = round(longitude, digits = 2),
         distances = hav_dist(latitude, longitude, latitude2, longitude2))

up_2d <- map_dfc(1:5, function(x) trajectory_uniqueness(trajectories_2d[,c(1, 4, 5)], num_points = x, nits = 100))
save(up_2d, file = '../Data/pct_unique_2d.RData')
#load('pct_unique_2d.RData')

colnames(up_2d) <- pvar_names

up_2d <- up_2d %>%
  gather(key = 'num_points', value = 'percent_unique') %>%
  mutate(specificity = 2)

ridge_plot(up_2d, 'Two Decimal Lat/Long') / dist_plot(trajectories_2d, 'Two Decimal Lat/Long')
```

```{r}
(q2d <- dist_quants(trajectories_2d) %>% mutate(specificity = 2))
```

Now, we will round `latitude` and `longitude` simultaneously to one decimal. Rounding from two decimals to one decimal results in a change of ___________ meters depending on distance from the equator.
```{r message = FALSE}
trajectories_1d <- trajectories %>%
  mutate(latitude2 = round(latitude, digits = 1),
         longitude2 = round(longitude, digits = 1),
         distances = hav_dist(latitude, longitude, latitude2, longitude2))

up_1d <- map_dfc(1:5, function(x) trajectory_uniqueness(trajectories_1d[,c(1, 4, 5)], num_points = x, nits = 100))
save(up_1d, file = '../Data/pct_unique_1d.RData')
#load('pct_unique_1d.RData')

colnames(up_1d) <- pvar_names

up_1d <- up_1d %>%
  gather(key = 'num_points', value = 'percent_unique') %>%
  mutate(specificity = 1)

ridge_plot(up_1d, 'One Decimal Lat/Long') / dist_plot(trajectories_1d, 'One Decimal Lat/Long')
```

```{r}
(q1d <- dist_quants(trajectories_1d) %>% mutate(specificity = 1))
```

Now, we will round `latitude` and `longitude` simultaneously to zero decimals. Rounding from one decimal to zero decimals results in a change of ___________ meters depending on distance from the equator.
```{r message = FALSE}
trajectories_0d <- trajectories %>%
  mutate(latitude2 = round(latitude, digits = 0),
         longitude2 = round(longitude, digits = 0),
         distances = hav_dist(latitude, longitude, latitude2, longitude2))

up_0d <- map_dfc(1:5, function(x) trajectory_uniqueness(trajectories_0d[,c(1, 4, 5)], num_points = x, nits = 100))
save(up_0d, file = '../Data/pct_unique_0d.RData')
#load('pct_unique_0d.RData')

colnames(up_0d) <- pvar_names

up_0d <- up_0d %>%
  gather(key = 'num_points', value = 'percent_unique') %>%
  mutate(specificity = 0)

ridge_plot(up_0d, 'Zero Decimal Lat/Long') / dist_plot(trajectories_0d, 'Zero Decimal Lat/Long')
```

```{r}
(q0d <- dist_quants(trajectories_0d) %>% mutate(specificity = 0))
```

```{r fig.height=10}
full_pd <- up_5d %>%
  bind_rows(up_4d, up_3d, up_2d, up_1d, up_0d)

q_stats <- tibble(Min = 0,
                  `2.5%` = 0,
                  `50%` = 0,
                  `97.5%` = 0,
                  Max = 0,
                  specificity = 5) %>%
  bind_rows(q4d, q3d, q2d, q1d, q0d) %>%
  select(specificity, Min, `50%`, Max) %>%
  group_by(specificity) %>%
  summarize(stat_txt = paste0(c('Min=', 'Median=', 'Max='),
                              c(round(Min, 2), round(`50%`, 2), round(Max, 2)),
                              collapse = '\n'))

boxes <- full_pd %>%
  mutate(specificity = factor(specificity, levels = c('0', '1', '2', '3', '4', '5')),
         num_points = factor(num_points, levels = c('one', 'two', 'three', 'four', 'five'))) %>%
  ggplot(aes(x = specificity, y = percent_unique, fill = factor(num_points))) +
  geom_boxplot() +
  labs(x = 'Number Decimal Places (Lat/Long)',
       y = '% Unique Trajectories',
       fill = '# Lat/Long Points\n') +
  scale_fill_discrete(labels = c('One', 'Two', 'Three', 'Four', 'Five'),
                      guide = guide_legend(reverse = TRUE)) +
  theme(legend.position = c(.9, .25),
        legend.justification = c('right', 'bottom'),
        legend.box.just = 'right')

annot <- q_stats %>%
  arrange(specificity) %>%
  ggplot(aes(x = specificity, y = 0)) +
  geom_text(aes(label = stat_txt), hjust = 'middle') +
  scale_x_discrete(breaks = NULL) +
  scale_y_continuous(breaks = NULL) +
  xlab(NULL) +
  ylab('') +
  theme_minimal() +
  theme(plot.title = element_text(size = 16), plot.subtitle = element_text(size = 12)) +
  labs(title = 'Uniqueness for Varying Trajectory Sample Size and Location Specificity For COVID-19 Patients\n',
       subtitle = 'Minimum, Median, and Maximum of Distances Shifted by Rounding (meters)')
  
grid.arrange(annot, boxes, heights = c(1, 5))
```





